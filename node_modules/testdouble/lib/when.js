// Generated by CoffeeScript 1.10.0
(function() {
  var _, addStubbing, callback, calls, concatImpliedCallback, log, stubbings,
    slice = [].slice;

  _ = require('lodash');

  calls = require('./store/calls');

  stubbings = require('./store/stubbings');

  callback = require('./matchers/callback');

  log = require('./log');

  module.exports = function(__userDoesPretendInvocationHere__, config) {
    if (config == null) {
      config = {};
    }
    return {
      thenReturn: function() {
        var stubbedValues;
        stubbedValues = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return addStubbing(stubbedValues, config, 'thenReturn');
      },
      thenCallback: function() {
        var stubbedValues;
        stubbedValues = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return addStubbing(stubbedValues, config, 'thenCallback');
      },
      thenDo: function() {
        var stubbedValues;
        stubbedValues = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return addStubbing(stubbedValues, config, 'thenDo');
      },
      thenThrow: function() {
        var stubbedValues;
        stubbedValues = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return addStubbing(stubbedValues, config, 'thenThrow');
      }
    };
  };

  addStubbing = function(stubbedValues, config, plan) {
    var last;
    _.assign(config, {
      plan: plan
    });
    if (last = calls.pop()) {
      stubbings.add(last.testDouble, concatImpliedCallback(last.args, config), stubbedValues, config);
      return last.testDouble;
    } else {
      return log.error("td.when", "No test double invocation call detected for `when()`.\n\n  Usage:\n    when(myTestDouble('foo')).thenReturn('bar')");
    }
  };

  concatImpliedCallback = function(args, config) {
    if (config.plan !== 'thenCallback') {
      return args;
    }
    if (!_(args).some(callback.isCallback)) {
      return args.concat(callback);
    } else {
      return args;
    }
  };

}).call(this);
