// Generated by CoffeeScript 1.10.0
(function() {
  var _, argsMatch, callback, callsStore, executePlan, hasTimesRemaining, invokeCallbackFor, isSatisfied, store, stubbedValueFor, stubbingFor;

  _ = require('lodash');

  store = require('./index');

  callsStore = require('./calls');

  argsMatch = require('../args-match');

  callback = require('../matchers/callback');

  module.exports = {
    add: function(testDouble, args, stubbedValues, config) {
      return store["for"](testDouble).stubbings.push({
        callCount: 0,
        stubbedValues: stubbedValues,
        args: args,
        config: config
      });
    },
    invoke: function(testDouble, actualArgs) {
      var stubbing;
      if (!(stubbing = stubbingFor(testDouble, actualArgs))) {
        return;
      }
      return executePlan(stubbing, actualArgs);
    },
    "for": function(testDouble) {
      return store["for"](testDouble).stubbings;
    }
  };

  stubbingFor = function(testDouble, actualArgs) {
    return _(store["for"](testDouble).stubbings).findLast(function(stubbing) {
      return isSatisfied(stubbing, actualArgs);
    });
  };

  executePlan = function(stubbing, actualArgs) {
    var value;
    value = stubbedValueFor(stubbing);
    stubbing.callCount += 1;
    invokeCallbackFor(stubbing, actualArgs);
    switch (stubbing.config.plan) {
      case "thenReturn":
        return value;
      case "thenDo":
        return value.apply(null, actualArgs);
      case "thenThrow":
        throw value;
    }
  };

  invokeCallbackFor = function(stubbing, actualArgs) {
    if (!_.some(stubbing.args, callback.isCallback)) {
      return;
    }
    return _.each(stubbing.args, function(expectedArg, i) {
      var callbackArgs;
      if (!callback.isCallback(expectedArg)) {
        return;
      }
      callbackArgs = expectedArg.args != null ? expectedArg.args : stubbing.config.plan === 'thenCallback' ? stubbing.stubbedValues : [];
      return actualArgs[i].apply(actualArgs, callbackArgs);
    });
  };

  stubbedValueFor = function(stubbing) {
    if (stubbing.callCount < stubbing.stubbedValues.length) {
      return stubbing.stubbedValues[stubbing.callCount];
    } else {
      return _.last(stubbing.stubbedValues);
    }
  };

  isSatisfied = function(stubbing, actualArgs) {
    return argsMatch(stubbing.args, actualArgs, stubbing.config) && hasTimesRemaining(stubbing);
  };

  hasTimesRemaining = function(stubbing) {
    if (stubbing.config.times == null) {
      return true;
    }
    return stubbing.callCount < stubbing.config.times;
  };

}).call(this);
