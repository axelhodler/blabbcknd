// Generated by CoffeeScript 1.10.0
(function() {
  describe('when', function() {
    Given(function() {
      return this.testDouble = td["function"]();
    });
    describe('no-arg stubbing', function() {
      context('foo', function() {
        Given(function() {
          return td.when(this.testDouble()).thenReturn("foo");
        });
        return Then(function() {
          return this.testDouble() === "foo";
        });
      });
      return context('bar', function() {
        Given(function() {
          return td.when(this.testDouble()).thenReturn("bar");
        });
        return Then(function() {
          return this.testDouble() === "bar";
        });
      });
    });
    describe('last-in-wins overwriting', function() {
      Given(function() {
        return td.when(this.testDouble("something")).thenReturn("gold");
      });
      Given(function() {
        return td.when(this.testDouble("something")).thenReturn("iron");
      });
      return Then(function() {
        return this.testDouble("something") === "iron";
      });
    });
    describe('conditional stubbing', function() {
      Given(function() {
        return td.when(this.testDouble(1)).thenReturn("foo");
      });
      Given(function() {
        return td.when(this.testDouble(2)).thenReturn("bar");
      });
      Given(function() {
        return td.when(this.testDouble({
          lol: 'cheese'
        })).thenReturn('nom');
      });
      Given(function() {
        return td.when(this.testDouble({
          lol: 'fungus'
        })).thenReturn('eww');
      });
      Given(function() {
        return td.when(this.testDouble({
          lol: 'fungus'
        }, 2)).thenReturn('eww2');
      });
      Then(function() {
        return this.testDouble() === void 0;
      });
      And(function() {
        return this.testDouble(1) === "foo";
      });
      And(function() {
        return this.testDouble(2) === "bar";
      });
      And(function() {
        return this.testDouble({
          lol: 'cheese'
        }) === "nom";
      });
      And(function() {
        return this.testDouble({
          lol: 'fungus'
        }) === "eww";
      });
      return And(function() {
        return this.testDouble({
          lol: 'fungus'
        }, 2) === "eww2";
      });
    });
    describe('multiple test doubles', function() {
      Given(function() {
        return this.td1 = td.when(td["function"]()()).thenReturn("lol1");
      });
      Given(function() {
        return this.td2 = td.when(td["function"]()()).thenReturn("lol2");
      });
      Then(function() {
        return this.td1() === "lol1";
      });
      return Then(function() {
        return this.td2() === "lol2";
      });
    });
    describe('using matchers', function() {
      Given(function() {
        return td.when(this.testDouble(88, td.matchers.isA(Number))).thenReturn("yay");
      });
      Then(function() {
        return this.testDouble(88, 5) === "yay";
      });
      Then(function() {
        return this.testDouble(44, 5) === void 0;
      });
      return Then(function() {
        return this.testDouble(88, "five") === void 0;
      });
    });
    describe('stubbing sequential returns', function() {
      context('a single stubbing', function() {
        Given(function() {
          return td.when(this.testDouble()).thenReturn(10, 9);
        });
        When(function() {
          var ref;
          return ref = [this.testDouble(), this.testDouble(), this.testDouble()], this.first = ref[0], this.second = ref[1], this.third = ref[2], ref;
        });
        Then(function() {
          return this.first === 10;
        });
        Then(function() {
          return this.second === 9;
        });
        return Then(function() {
          return this.third === 9;
        });
      });
      return context('two overlapping stubbings', function() {
        Given(function() {
          return td.when(this.testDouble()).thenReturn('A');
        });
        Given(function() {
          return this.testDouble();
        });
        Given(function() {
          return td.when(this.testDouble()).thenReturn('B', 'C');
        });
        return Then(function() {
          return this.testDouble() === 'B';
        });
      });
    });
    describe('stubbing actions with `thenDo` instead of `thenReturn`', function() {
      Given(function() {
        return this.someAction = td["function"]();
      });
      Given(function() {
        return td.when(this.testDouble(55)).thenDo(this.someAction);
      });
      When(function() {
        return this.testDouble(55);
      });
      return Then(function() {
        return td.verify(this.someAction(55));
      });
    });
    describe('stubbing actions with `thenThrow` instead of `thenReturn`', function() {
      Given(function() {
        return this.error = new Error('lol');
      });
      Given(function() {
        return td.when(this.testDouble(42)).thenThrow(this.error);
      });
      When(function() {
        var e, error;
        try {
          return this.testDouble(42);
        } catch (error) {
          e = error;
          return this.result = e;
        }
      });
      return Then(function() {
        return this.error === this.result;
      });
    });
    describe('stubbing error, no invocation found', function() {
      Given(function() {
        return td.reset();
      });
      Given(function() {
        var e, error;
        try {
          return td.when().thenReturn('hi');
        } catch (error) {
          e = error;
          return this.error = e;
        }
      });
      return Then(function() {
        return this.error.message === "Error: testdouble.js - td.when - No test double invocation call detected for `when()`.\n\n  Usage:\n    when(myTestDouble('foo')).thenReturn('bar')";
      });
    });
    return describe('config object', function() {
      describe('ignoring extra arguments', function() {
        context('for a no-arg stubbing', function() {
          Given(function() {
            return td.when(this.testDouble(), {
              ignoreExtraArgs: true
            }).thenReturn('pewpew');
          });
          When(function() {
            return this.result = this.testDouble('so', 'many', 'args');
          });
          return Then(function() {
            return this.result === 'pewpew';
          });
        });
        return context('when an initial-arg-matters', function() {
          Given(function() {
            return td.when(this.testDouble('important'), {
              ignoreExtraArgs: true
            }).thenReturn('neat');
          });
          context('satisfied without extra args', function() {
            return Then(function() {
              return this.testDouble('important') === 'neat';
            });
          });
          context('satisfied with extra args', function() {
            return Then(function() {
              return this.testDouble('important', 'not important') === 'neat';
            });
          });
          context('unsatisfied with no args', function() {
            return Then(function() {
              return this.testDouble() === void 0;
            });
          });
          return context('unsatisfied with extra args', function() {
            return Then(function() {
              return this.testDouble('unimportant', 'not important') === void 0;
            });
          });
        });
      });
      return describe('limiting times stubbing will work', function() {
        context('a single stub', function() {
          Given(function() {
            return td.when(this.testDouble(), {
              times: 2
            }).thenReturn('pants');
          });
          When(function() {
            return this.result = [this.testDouble(), this.testDouble(), this.testDouble()];
          });
          return Then(function() {
            return expect(this.result).to.deep.equal(['pants', 'pants', void 0]);
          });
        });
        return context('two overlapping stubbings', function() {
          Given(function() {
            return td.when(this.testDouble()).thenReturn('NO');
          });
          Given(function() {
            return td.when(this.testDouble(), {
              times: 1
            }).thenReturn('YES');
          });
          When(function() {
            return this.result = [this.testDouble(), this.testDouble(), this.testDouble()];
          });
          return Then(function() {
            return expect(this.result).to.deep.equal(['YES', 'NO', 'NO']);
          });
        });
      });
    });
  });

}).call(this);
